/*
 * Adnan Amir
 * Spring 2024
 * CS 5330
 * In collaboration with Prem Sukhadwala
 */
#include "opencv2/opencv.hpp"
#include "../include/filter.h"
#include "opencv2/imgcodecs.hpp"
#define CV_HAAR_SCALE_IMAGE 2

using namespace cv;

/*
 * Greyscale using cvtColor function, generates a single channel mat
 */
int grey(cv::Mat &src, cv::Mat &dst) {
    std::vector<cv::Mat> channels;
    cvtColor(src, dst, cv::COLOR_BGR2GRAY);
    for (int i=0;i<3;i++){ //Prevent crashes due to switching from 1 to 3 channel filters
    channels.push_back(dst);
    }
    merge(channels, dst); //create a 3 channel greyscale
    return 0;
}

/*
 * Alternative Greyscale using ptr method, generates a 3 channel inverted greyscale image (all 3 channels have same value)
 */
int alt_grey(cv::Mat &src, cv::Mat &dst){
    for (int i=0; i < src.rows; i++){
        cv::Vec3b *ptr= src.ptr<cv::Vec3b>(i);
        cv::Vec3b *dptr= dst.ptr<cv::Vec3b>(i);
        for (int j=0; j < src.cols; j++){
            int val= 255 - ptr[j][0]; //blue channel pixel
            for (int k=0; k<3; k++){//copy to other dst pixels accross all channels
                dptr[j][k]=val;
            }
        }
    }
    return 0;
}

/*
 * Sepia tone filter is a weighted sum of all source pixels.
 * You can invert the red and blue/greeb coefficients to get a different hue of sepia
 */

int sepia(cv::Mat &src, cv::Mat &dst){
    float b_const[3]={0.272, 0.534, 0.131};
    float g_const[3]={0.349, 0.686, 0.168};
    float r_const[3]={0.393, 0.769, 0.189};
    for (int i=0; i < src.rows; i++){
        cv::Vec3b *ptr= src.ptr<cv::Vec3b>(i);
        cv::Vec3b *dptr= dst.ptr<cv::Vec3b>(i);
        for (int j=0; j < src.cols; j++){
            int px[3]={ptr[j][0],ptr[j][1],ptr[j][2]};
            dptr[j][0]=fmin(255,b_const[0]*px[2]+b_const[1]*px[1]+b_const[2]*px[0]);//blue
            dptr[j][1]=fmin(255,g_const[0]*px[2]+g_const[1]*px[1]+g_const[2]*px[0]);//green
            dptr[j][2]=fmin(255,r_const[0]*px[2]+r_const[1]*px[1]+r_const[2]*px[0]);//red
        }
    }
    return 0;
}

/*
 * General function for applying the sobel filters. Since the X and Y sobel filters are transposes of each other,
 * We can interchange the horizontal and vertical kernals to get the required direction of sobel filter.
 */

int sobel(cv::Mat &src, cv::Mat &dst, const int hk[3],const int vk[3],const int norm[2]) {

    Mat inter;
    inter.create(src.size(), CV_16SC3); // allocate space for an intermediary mat
                                                  // (IMPORTANT: To prevent heap corruption error)

    for (int i = 1; i < src.rows-1; i++){//vertical filter application
        cv::Vec3b *top = src.ptr<cv::Vec3b>(i-1); //pointers to top, mid and bottom rows
        cv::Vec3b *mid = src.ptr<cv::Vec3b>(i);
        cv::Vec3b *bot = src.ptr<cv::Vec3b>(i+1);
        cv::Vec3s *iptr = inter.ptr<cv::Vec3s>(i); //pointer to intermediary variable row

        for(int j = 0; j < src.cols; j++){//cols
            for (int k = 0; k < src.channels(); k++){//color channels
                iptr[j][k] = vk[0] * bot[j][k] + vk[1] * mid[j][k] + vk[2] * top[j][k]/norm[1];//make sure to normalize
            }
        }

    }

    dst.create(inter.size(), CV_16SC3);// allocate space for dst
    for (int i = 0; i < inter.rows; i++) {// Apply horizontal filter
        cv::Vec3s *ptr = inter.ptr<cv::Vec3s>(i); //source pointer (intermediary)
        cv::Vec3s *dptr = dst.ptr<cv::Vec3s>(i); //dst pointer
        for (int j = 1; j < inter.cols-1; j++){
            for(int k = 0; k < inter.channels(); k++){
                dptr[j][k] = hk[0] * ptr[j-1][k] + hk[1] * ptr[j][k] + hk[2] * ptr[j+1][k]/norm[0];//make sure to normalize
            }
        }

    }
    return 0;
}

/*
 * Sobel X filter
 *          [1;   [-1 0 1;
 *[-1 0 1] x 2; =  -2 0 2;
 *           1]    -1 0 1]
 */

int sobelX3x3 (cv::Mat &src, cv::Mat &dst){
    int hk[3] = {-1, 0, 1};
    int vk[3] = {1, 2, 1};
    const int norm[2]={1,4};
    sobel(src,dst,hk,vk,norm);
    return 0;
}

/*
 * Sobel Y filter
 *          [ 1;   [1  2  1;
 *[1 2 1] x   0; =  0  0  0;
 *           -1]   -1 -2 -1]
 */


int sobelY3x3 (cv::Mat &src, cv::Mat &dst){
    int vk[3] = {1, 0, -1};
    int hk[3] = {1, 2, 1};
    const int norm[2]={4,1}; //h,v
    sobel(src,dst,hk,vk,norm);
    return 0;
}


/*
 * Magnitude image is generated by taking magnitude of each pixel
 * of sobel gradients in x and y direction
 */
int magnitude( cv::Mat &sx, cv::Mat &sy, cv::Mat &dst ){
    dst.create(sx.size(), CV_16SC3);
    for (int i=0;i < sx.rows; i++){
        cv::Vec3s *xptr = sx.ptr<cv::Vec3s>(i);//to acces sx rows
        cv::Vec3s *yptr = sy.ptr<cv::Vec3s>(i);//to acces sy rows
        cv::Vec3s *dptr = dst.ptr<cv::Vec3s>(i);//to acces dst rows
        for(int j=0; j<sx.cols; j++){
            for(int k=0; k<sx.channels(); k++){
                dptr[j][k]=sqrt((xptr[j][k]*xptr[j][k])+(yptr[j][k]*yptr[j][k]));
            }
        }
    }
    return 0;
}

/*
 * Negative Image is created by taking colours from
 * the opposite ends of the spectrum. This is done
 * by 255-px thus white becomes black and same with
 * other colors (they become negatives)
 */

int negative (cv::Mat &src, cv::Mat &dst){
    for (int i=0; i < src.rows; i++){
        cv::Vec3b *ptr = src.ptr<cv::Vec3b>(i);
        cv::Vec3b *dptr = dst.ptr<cv::Vec3b>(i);

        for (int j = 0; j < src.cols; j++) {
            for (int k = 0; k < src.channels(); k++){
                dptr[j][k]=255-ptr[j][k];
            }
        }
    }
    return 0;
}

/*
 * Helper Function to genrate a 3 channel grey image for the emboss function.
 * Also Prem sukhadwala's alt_grey function
 */

int grey_3c(cv::Mat &src, cv::Mat &dst){//Creates a 3-channel greyscale image for embossing
    for (int i=0; i < src.rows; i++){
        cv::Vec3b *ptr= src.ptr<cv::Vec3b>(i);
        cv::Vec3b *dptr= dst.ptr<cv::Vec3b>(i);
        for (int j=0; j < src.cols; j++){
            int val= ptr[j][0]; //blue channel pixel
            for (int k=0; k<3; k++){//copy to other dst pixels accross all channels
                dptr[j][k]=val;
            }
        }
    }
    return 0;
}

/*
 * Embossing makes the ridges in an image stand out.
 * This is done by giving the outlines a direction (ie dot product with sobel image)
 * so it looks like light is bouncing off the ridges
 */

int emboss (cv::Mat &src, cv::Mat &dst, const float dir[2]) {
    Mat sx,sy;
    grey_3c(src,src);// create a 3 channel greyscale
    sobelX3x3(src,sx);
    sobelY3x3(src,sy);
    dst.create(sx.size(), CV_16SC3);
    dst= sx*dir[0]+sy*dir[1];//directional dot product of mats
    return 0;
};

/*
 * Slow blur function using at method, takes approx 200ms per frame
 * applies this filter [1 2 4 2 1
 *                      2 4 8 4 2
 *                      4 8 16 8 4
 *                      2 4 8 4 2
 *                      1 2 4 2 1]
 */

int blur5x5_1(Mat &src, Mat &dst){       //pass images by reference
    src.copyTo(dst);    //copies the image to dst

    for(int i=2;i<src.rows-2;i++){//access rows
        for(int j=2;j<src.cols-2;j++){//cols
            for(int k =0;k<src.channels();k++){//channel

                int sumRow0 = src.at<Vec3b>(i-2,j-2)[k]*1 + src.at<Vec3b>(i-2,j-1)[k]*2 + src.at<Vec3b>(i-2,j)[k]*4
                              + src.at<Vec3b>(i-2,j+1)[k]*2 + src.at<Vec3b>(i-2,j+2)[k]*1;

                int sumRow1 = src.at<Vec3b>(i-1,j-2)[k]*2 + src.at<Vec3b>(i-1,j-1)[k]*4 + src.at<Vec3b>(i-1,j)[k]*8
                              + src.at<Vec3b>(i-1,j+1)[k]*4 + src.at<Vec3b>(i-1,j+2)[k]*2;

                int sumRow2 = src.at<Vec3b>(i,j-2)[k]*4 + src.at<Vec3b>(i,j-1)[k]*8 + src.at<Vec3b>(i,j)[k]*16
                              + src.at<Vec3b>(i,j+1)[k]*8 + src.at<Vec3b>(i,j+2)[k]*4;

                int sumRow3 = src.at<Vec3b>(i+1,j-2)[k]*2 + src.at<Vec3b>(i+1,j-1)[k]*4 + src.at<Vec3b>(i+1,j)[k]*8
                              + src.at<Vec3b>(i+1,j+1)[k]*4 + src.at<Vec3b>(i+1,j+2)[k]*2;

                int sumRow4 = src.at<Vec3b>(i+2,j-2)[k]*1 + src.at<Vec3b>(i+2,j-1)[k]*2 + src.at<Vec3b>(i+2,j)[k]*4
                              + src.at<Vec3b>(i+2,j+1)[k]*2 + src.at<Vec3b>(i+2,j+2)[k]*1;

                int totalSum = sumRow0 + sumRow1 + sumRow2 + sumRow3 + sumRow4;

                // normalize
                totalSum/=100;

                dst.at<Vec3b>(i,j)[k] = totalSum;

            }
        }
    }

    return(0);
}

/*
 * Fast blur function using ptr method, takes approx 100ms per frame
 * applies this filter [1 2 4 2 1
 *                      2 4 8 4 2
 *                      4 8 16 8 4
 *                      2 4 8 4 2
 *                      1 2 4 2 1]
 */

int blur5x5_2( cv::Mat &src, cv::Mat &dst ){
    src.copyTo(dst);

    for(int i=2;i<src.rows-2;i++){
        Vec3b *ptruup = src.ptr<Vec3b>(i-2);    //pointer to data in row i-2
        Vec3b *ptrup = src.ptr<Vec3b>(i-1);     //pointer to data in row i-1
        Vec3b *ptr = src.ptr<Vec3b>(i);         //pointer to data in row i
        Vec3b *ptrdn = src.ptr<Vec3b>(i+1);     //pointer to data in row i+1
        Vec3b *ptrddn = src.ptr<Vec3b>(i+2);    //pointer to data in row i+2
        Vec3b *dstPtr = dst.ptr<Vec3b>(i);      //pointer to data in row i in destination image

        for(int j=2;j<src.cols-2;j++){
            for(int k =0;k<src.channels();k++){
                int sumRow0 = ptruup[j-2][k]*1 + ptruup[j-1][k]*2 + ptruup[j][k]*4 + ptruup[j+1][k]*2 + ptruup[j+2][k]*1;
                int sumRow1 = ptrup[j-2][k]*2 + ptrup[j-1][k]*4 + ptrup[j][k]*8 + ptrup[j+1][k]*4 + ptrup[j+2][k]*2;
                int sumRow2 = ptr[j-2][k]*4 + ptr[j-1][k]*8 + ptr[j][k]*16 + ptr[j+1][k]*8 + ptr[j+2][k]*4;
                int sumRow3 = ptrdn[j-2][k]*2 + ptrdn[j-1][k]*4 + ptrdn[j][k]*8 + ptrdn[j+1][k]*4 + ptrdn[j+2][k]*2;
                int sumRow4 = ptrddn[j-2][k]*1 + ptrddn[j-1][k]*2 + ptrddn[j][k]*4 + ptrddn[j+1][k]*2 + ptrddn[j+2][k]*1;

                int totalSum = sumRow0 + sumRow1 + sumRow2 + sumRow3 + sumRow4;

                // normalize
                totalSum/=100;

                dstPtr[j][k] = totalSum;


            }
        }
    }

    return(0);
}

/*
 * Applies blur function then quantizes the image into buckets, which are determined by levels.
 * 255 buckets is a normal image, lesser than that means lesser variety colors since pixels can take less than 255 values
 */

int blurQuantize( cv::Mat &src, cv::Mat &dst, int levels ){
    src.copyTo(dst);
    float bucket = 255/levels;
    for(int i=2;i<src.rows-2;i++){
        Vec3b *ptruup = src.ptr<Vec3b>(i-2);    //pointer to data in row i-2
        Vec3b *ptrup = src.ptr<Vec3b>(i-1);     //pointer to data in row i-1
        Vec3b *ptr = src.ptr<Vec3b>(i);         //pointer to data in row i
        Vec3b *ptrdn = src.ptr<Vec3b>(i+1);     //pointer to data in row i+1
        Vec3b *ptrddn = src.ptr<Vec3b>(i+2);    //pointer to data in row i+2
        Vec3b *dstPtr = dst.ptr<Vec3b>(i);      //pointer to data in row i in destination image

        for(int j=2;j<src.cols-2;j++){
            for(int k =0;k<src.channels();k++){
                int sumRow0 = ptruup[j-2][k]*1 + ptruup[j-1][k]*2 + ptruup[j][k]*4 + ptruup[j+1][k]*2 + ptruup[j+2][k]*1;
                int sumRow1 = ptrup[j-2][k]*2 + ptrup[j-1][k]*4 + ptrup[j][k]*8 + ptrup[j+1][k]*4 + ptrup[j+2][k]*2;
                int sumRow2 = ptr[j-2][k]*4 + ptr[j-1][k]*8 + ptr[j][k]*16 + ptr[j+1][k]*8 + ptr[j+2][k]*4;
                int sumRow3 = ptrdn[j-2][k]*2 + ptrdn[j-1][k]*4 + ptrdn[j][k]*8 + ptrdn[j+1][k]*4 + ptrdn[j+2][k]*2;
                int sumRow4 = ptrddn[j-2][k]*1 + ptrddn[j-1][k]*2 + ptrddn[j][k]*4 + ptrddn[j+1][k]*2 + ptrddn[j+2][k]*1;

                int totalSum = sumRow0 + sumRow1 + sumRow2 + sumRow3 + sumRow4;

                // normalize
                totalSum/=100;

                dstPtr[j][k] = totalSum;


            }
        }
    }

    for(int m=0;m<src.rows;m++){//quantization
        for(int n=0;n<src.cols;n++){
            for(int h=0;h<src.channels();h++){

                int t = dst.at<Vec3b>(m,n)[h]/bucket;  //temp variable
                dst.at<Vec3b>(m,n)[h] = t*bucket;
            }
        }
    }

    return(0);
}

// Implements a mirror effect, flips around Y axis
int mirror(Mat &src, Mat &dst){
    dst.create(src.size(), src.type());

    for(int i=0;i<src.rows;i++){
        for(int j=0, l = src.cols-1;j<src.cols;j++,--l){//src image starts at last px and dst starts at 1st
            for(int k =0;k<src.channels();k++){
                int temp = src.at<Vec3b>(i,l)[k];//swap pixels
                dst.at<Vec3b>(i,l)[k] = src.at<Vec3b>(i,j)[k];
                dst.at<Vec3b>(i,j)[k] = temp;
            }
        }
    }



    return(0);
}

/*
 * Combines sobel magnitude and blurquantize image
 */

int cartoon(cv::Mat &src, cv::Mat &dst, int levels, int magThreshold) {
    cv::Mat sx(src.rows, src.cols, CV_16SC3);
    sobelX3x3(src, sx);

    cv::Mat sy(src.rows, src.cols, CV_16SC3);
    sobelY3x3(src, sy);

    cv::Mat mag(src.rows, src.cols, CV_8UC3);
    magnitude(sx, sy, mag);

    blurQuantize(src, dst, levels);

    for (int i = 0; i < dst.rows; i++) {
        for (int j = 0; j < dst.cols; j++) {//using ptr method to access both
            uchar* magPixel = mag.ptr<uchar>(i, j);
            uchar* dstPixel = dst.ptr<uchar>(i, j);

            for (int channel = 0; channel < 3; channel++) {//if magnitude pixel is above a threshold, remove it
                if (magPixel[channel] > magThreshold) {
                    dstPixel[channel] = 0;
                }
            }
        }
    }

    return 0;
}

/*
 * Puts glasses on the eyes using eye casacade detector
 */
int coolmode(cv::Mat &src, cv::Mat &dst){
    using namespace std;
    std::string faceCascadeName = "../classifier/haarcascade_frontalface_alt2.xml";
    std::string eyeCascadeName = "../classifier/haarcascade_eye.xml";
    CascadeClassifier faceCascade, eyeCascade;

    if( !faceCascade.load(faceCascadeName) )
    {
        cerr << "Error loading face cascade file. Exiting!" << endl;
        return -1;
    }

    if( !eyeCascade.load(eyeCascadeName) )
    {
        cerr << "Error loading eye cascade file. Exiting!" << endl;
        return -1;
    }

    Mat eyeMask = imread("../img/glasses3.jpg");

    if ( !eyeMask.data )
    {
        cerr << "Error loading mask image. Exiting!" << endl;
    }

    Mat dstGray;
    Mat frameROI, eyeMaskSmall;
    Mat grayMaskSmall, grayMaskSmallThresh, grayMaskSmallThreshInv;
    Mat maskedEye, maskedFrame;
    src.copyTo(dst);

    float scalingFactor = 0.5; //make frame 50% smaller for processing
    vector<Rect> faces;
    resize(dst, dst, Size(), scalingFactor, scalingFactor, INTER_AREA);
    cvtColor(dst, dstGray, COLOR_BGR2GRAY);
    equalizeHist(dstGray, dstGray);
    // Detect faces
    faceCascade.detectMultiScale(dstGray, faces, 1.1, 2, 0|CV_HAAR_SCALE_IMAGE, Size(30, 30) );

    vector<Point> centers;

    // Draw green circles around the eyes
    for(int i = 0; i < faces.size(); i++)
    {
        Mat faceROI = dstGray(faces[i]);
        vector<Rect> eyes;

        // In each face, detect eyes
        eyeCascade.detectMultiScale(faceROI, eyes, 1.1, 2, 0 |CV_HAAR_SCALE_IMAGE, Size(30, 30));

        // For each eye detected, compute the center
        for(int j = 0; j < eyes.size(); j++)
        {
            Point center( faces[i].x + eyes[j].x + int(eyes[j].width*0.5), faces[i].y + eyes[j].y + int(eyes[j].height*0.5) );
            centers.push_back(center);
        }
    }

    // Overlay sunglasses only if both eyes are detected
    if(centers.size() == 2)
    {
        Point leftPoint, rightPoint;

        // Identify the left and right eyes
        if(centers[0].x < centers[1].x)
        {
            leftPoint = centers[0];
            rightPoint = centers[1];
        }
        else
        {
            leftPoint = centers[1];
            rightPoint = centers[0];
        }

        // Custom parameters to make the sunglasses fit your face. Tuned to my face.
        int w = 3.3 * (rightPoint.x - leftPoint.x);
        int h = int(0.9 * w);
        int x = leftPoint.x - 0.28*w;
        int y = leftPoint.y - 0.5*h;

        // Extract region of interest (ROI) covering both the eyes
        frameROI = dst(Rect(x,y,w,h));

        // Resize the sunglasses image based on the dimensions of the above ROI
        resize(eyeMask, eyeMaskSmall, Size(w,h));

        // Convert the above image to grayscale
        cvtColor(eyeMaskSmall, grayMaskSmall, COLOR_BGR2GRAY);

        // Threshold the above image to isolate the foreground object
        threshold(grayMaskSmall, grayMaskSmallThresh, 245, 255, THRESH_BINARY_INV);

        // Create mask by inverting the above image (because we don't want the background to affect the overlay)
        bitwise_not(grayMaskSmallThresh, grayMaskSmallThreshInv);

        // Use bitwise "AND" operator to extract precise boundary of sunglasses
        bitwise_and(eyeMaskSmall, eyeMaskSmall, maskedEye, grayMaskSmallThresh);

        // Use bitwise "AND" operator to overlay sunglasses
        bitwise_and(frameROI, frameROI, maskedFrame, grayMaskSmallThreshInv);

        // Add the above masked images and place it in the original frame ROI to create the final image
        add(maskedEye, maskedFrame, dst(Rect(x,y,w,h)));
    }
}


